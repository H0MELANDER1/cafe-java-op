atbash

package AtbashCipher;

import java.util.Scanner;

public class AtbashCipher {
    // Encrypt/Decrypt text using Atbash cipher
    public static String atbash(String text) {
        StringBuilder result = new StringBuilder();

        for (int i = 0; i < text.length(); i++) {
            char ch = text.charAt(i);

            if (Character.isUpperCase(ch)) {
                result.append((char) ('Z' - (ch - 'A')));
            } else if (Character.isLowerCase(ch)) {
                result.append((char) ('z' - (ch - 'a')));
            } else {
                result.append(ch); // Non-alphabet characters remain unchanged
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter the text to apply Atbash cipher on:");
        String text = scanner.nextLine();

        String encryptedText = atbash(text);
        System.out.println("Encrypted/Decrypted Text: " + encryptedText);

        scanner.close();
    }
}

-------------------------------------------------------

ceaser ciper


package CaesarCipher;

import java.util.Scanner;

public class CaesarCipher {

    // Encrypts text using a shift of 3
    public static String encrypt(String text) {
        return encrypt(text, 3);
    }

    // Decrypts text using a shift of 3
    public static String decrypt(String text) {
        return decrypt(text, 3);
    }

    // Encrypts text using the specified shift (key)
    public static String encrypt(String text, int shift) {
        StringBuilder result = new StringBuilder();

        // Loop through each character in the input string
        for (int i = 0; i < text.length(); i++) {
            char ch = text.charAt(i);

            // Encrypt uppercase characters
            if (Character.isUpperCase(ch)) {
                char c = (char) (((ch - 'A' + shift) % 26) + 'A');
                result.append(c);
            }
            // Encrypt lowercase characters
            else if (Character.isLowerCase(ch)) {
                char c = (char) (((ch - 'a' + shift) % 26) + 'a');
                result.append(c);
            }
            // If it's not a letter, just append it as it is
            else {
                result.append(ch);
            }
        }
        return result.toString();
    }

    // Decrypts text using the specified shift (key)
    public static String decrypt(String text, int shift) {
        // To decrypt, we encrypt with the inverse shift
        return encrypt(text, 26 - shift);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter the text to encrypt:");
        String text = scanner.nextLine();

        String encryptedText = encrypt(text);
        System.out.println("Encrypted Text: " + encryptedText);

        String decryptedText = decrypt(encryptedText);
        System.out.println("Decrypted Text: " + decryptedText);

        scanner.close();
    }
}


--------------------------------

railfence

package RailFenceCipher;

import java.util.Scanner;

public class RailFenceCipher {

    // Encrypt text using the Rail Fence Cipher
    public static String encrypt(String text, int key) {
        char[][] rail = new char[key][text.length()];
        boolean down = false;
        int row = 0, col = 0;

        // Build the rail fence
        for (int i = 0; i < text.length(); i++) {
            if (row == 0 || row == key - 1) {
                down = !down; // Change direction at top or bottom rail
            }
            rail[row][col++] = text.charAt(i); // Place character
            row += down ? 1 : -1;
        }

        // Collect characters from the rail
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < key; i++) {
            for (int j = 0; j < text.length(); j++) {
                if (rail[i][j] != 0) {
                    result.append(rail[i][j]);
                }
            }
        }
        return result.toString();
    }
    
    // Decrypt text using the Rail Fence Cipher
    public static String decrypt(String cipher, int key) {
        char[][] rail = new char[key][cipher.length()];
        boolean down = false;
        int row = 0, col = 0;

        for (int i = 0; i < cipher.length(); i++) {
            if (row == 0 || row == key - 1) {
                down = !down;
            }
            rail[row][col++] = '*';
            row += down ? 1 : -1;
        }

        int index = 0;
        for (int i = 0; i < key; i++) {
            for (int j = 0; j < cipher.length(); j++) {
                if (rail[i][j] == '*' && index < cipher.length()) {
                    rail[i][j] = cipher.charAt(index++);
                }
            }
        }

        StringBuilder result = new StringBuilder();
        row = 0;
        col = 0;
        down = false;

        for (int i = 0; i < cipher.length(); i++) {
            if (row == 0 || row == key - 1) {
                down = !down;
            }
            if (rail[row][col] != '*') {
                result.append(rail[row][col++]);
            }
            row += down ? 1 : -1;
        }

        return result.toString();
    }


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter the text to encrypt:");
        String text = scanner.nextLine();

        System.out.println("Enter the number of rails:");
        int key = scanner.nextInt();

        String encryptedText = encrypt(text, key);
        System.out.println("Encrypted Text: " + encryptedText);

        String decryptedText = decrypt(encryptedText, key);
        System.out.println("Decrypted Text: " + decryptedText);
        
        scanner.close();
    }
}

----------------------

rot13

package ROT13;

import java.util.Scanner;

public class ROT13 {
    // Encrypt/Decrypt text using ROT13
    public static String rot13(String text) {
        StringBuilder result = new StringBuilder();

        for (int i = 0; i < text.length(); i++) {
            char ch = text.charAt(i);

            // Check if it's a letter
            if (ch >= 'a' && ch <= 'z') {
                result.append((char) (((ch - 'a' + 13) % 26) + 'a'));
            } else if (ch >= 'A' && ch <= 'Z') {
                result.append((char) (((ch - 'A' + 13) % 26) + 'A'));
            } else {
                result.append(ch); // Non-alphabet characters remain the same
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter the text to apply ROT13 on:");
        String text = scanner.nextLine();

        String encryptedText = rot13(text);
        System.out.println("Encrypted/Decrypted Text: " + encryptedText);
        
        scanner.close();
    }
}


--------------------------

vigenere


package VigenereCipher;

import java.util.Scanner;

public class VigenereCipher {

    // Encrypt the text using Vigenere cipher
    public static String encrypt(String text, String key) {
        StringBuilder result = new StringBuilder();
        key = key.toLowerCase();
        for (int i = 0, j = 0; i < text.length(); i++) {
            char ch = text.charAt(i);

            // Encrypt only alphabetic characters
            if (Character.isLetter(ch)) {
                char base = Character.isUpperCase(ch) ? 'A' : 'a';
                ch = (char) ((ch - base + (key.charAt(j % key.length()) - 'a')) % 26 + base);
                j++; // Only increment key index if it's a letter
            }
            result.append(ch);
        }
        return result.toString();
    }

    // Decrypt the text using Vigenere cipher
    public static String decrypt(String text, String key) {
        StringBuilder result = new StringBuilder();
        key = key.toLowerCase();
        for (int i = 0, j = 0; i < text.length(); i++) {
            char ch = text.charAt(i);

            // Decrypt only alphabetic characters
            if (Character.isLetter(ch)) {
                char base = Character.isUpperCase(ch) ? 'A' : 'a';
                ch = (char) ((ch - base - (key.charAt(j % key.length()) - 'a') + 26) % 26 + base);
                j++; // Only increment key index if it's a letter
            }
            result.append(ch);
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter the text to encrypt:");
        String text = scanner.nextLine();

        System.out.println("Enter the key:");
        String key = scanner.nextLine();

        String encryptedText = encrypt(text, key);
        System.out.println("Encrypted Text: " + encryptedText);

        String decryptedText = decrypt(encryptedText, key);
        System.out.println("Decrypted Text: " + decryptedText);

        scanner.close();
    }
}


-------------------------------------

Symmetric encryption (AES)


import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import java.security.SecureRandom;
import java.util.Base64;

public final class AESGCM {
    private static final String CIPHER = "AES/GCM/NoPadding";
    private static final int AES_KEY_BITS = 256;
    private static final int GCM_IV_BYTES = 12;
    private static final int GCM_TAG_BITS = 128;
    private static final SecureRandom RNG = new SecureRandom();

    public static SecretKey generateKey() throws Exception {
        KeyGenerator kg = KeyGenerator.getInstance("AES");
        kg.init(AES_KEY_BITS, RNG);
        return kg.generateKey();
    }
    public static String encrypt(SecretKey key, byte[] plaintext) throws Exception {
        byte[] iv = new byte[GCM_IV_BYTES];
        RNG.nextBytes(iv);
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_BITS, iv);
        Cipher cipher = Cipher.getInstance(CIPHER);
        cipher.init(Cipher.ENCRYPT_MODE, key, spec);
        byte[] ciphertext = cipher.doFinal(plaintext);

        // prepend IV for transport: IV || ciphertext
        byte[] out = new byte[iv.length + ciphertext.length];
        System.arraycopy(iv, 0, out, 0, iv.length);
        System.arraycopy(ciphertext, 0, out, iv.length, ciphertext.length);
        return Base64.getEncoder().encodeToString(out);
    }
    public static byte[] decrypt(SecretKey key, String b64IvAndCiphertext) throws Exception {
        byte[] ivAndCipher = Base64.getDecoder().decode(b64IvAndCiphertext);
        byte[] iv = new byte[GCM_IV_BYTES];
        System.arraycopy(ivAndCipher, 0, iv, 0, GCM_IV_BYTES);
        byte[] ciphertext = new byte[ivAndCipher.length - GCM_IV_BYTES];
        System.arraycopy(ivAndCipher, GCM_IV_BYTES, ciphertext, 0, ciphertext.length);

        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_BITS, iv);
        Cipher cipher = Cipher.getInstance(CIPHER);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);
        return cipher.doFinal(ciphertext);
    }
    // Example usage
    public static void main(String[] args) throws Exception {
        SecretKey key = generateKey();
        String ciphertext = encrypt(key, "A".getBytes("UTF-8"));
        System.out.println("Ciphertext: " + ciphertext);
        byte[] plaintext = decrypt(key, ciphertext);
        System.out.println("Plaintext: " + new String(plaintext, "UTF-8"));
    }
}


-------------------------------------
Asymmetric encryption - RSA


import java.security.*;
import javax.crypto.Cipher;
import java.util.Base64;
public final class RSAOAEP {
    private static final String RSA_ALG = "RSA/ECB/OAEPWithSHA-256AndMGF1Padding";

    public static KeyPair generateKeyPair(int keySize) throws Exception {
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(keySize, new SecureRandom());
        return kpg.generateKeyPair();
    }
    public static String encrypt(PublicKey publicKey, byte[] plaintext) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALG);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        byte[] cipherBytes = cipher.doFinal(plaintext);
        return Base64.getEncoder().encodeToString(cipherBytes);
    }
    public static byte[] decrypt(PrivateKey privateKey, String b64Ciphertext) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALG);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        byte[] cipherBytes = Base64.getDecoder().decode(b64Ciphertext);
        return cipher.doFinal(cipherBytes);
    }
    // Example usage
    public static void main(String[] args) throws Exception {
        KeyPair kp = generateKeyPair(2048);
        String c = encrypt(kp.getPublic(), "A".getBytes("UTF-8"));
        System.out.println("RSA cipher: " + c);
        System.out.println("RSA plain: " + new String(decrypt(kp.getPrivate(), c), "UTF-8"));
    }
}


---------------------------------

Hashing (SHA-256, SHA-512) and message digests

import java.security.MessageDigest;
import java.util.Base64;
public final class Hashing {
    public static String sha256Base64(byte[] input) throws Exception {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] digest = md.digest(input);
        return Base64.getEncoder().encodeToString(digest);
    }
    public static String sha512Hex(byte[] input) throws Exception {
        MessageDigest md = MessageDigest.getInstance("SHA-512");
        byte[] d = md.digest(input);
        StringBuilder sb = new StringBuilder(d.length * 2);
        for (byte b : d) sb.append(String.format("%02x", b));
        return sb.toString();
    }
    public static void main(String[] args) throws Exception {
        String s = "A";
        System.out.println("SHA-256 (Base64): " + sha256Base64(s.getBytes("UTF-8")));
        System.out.println("SHA-512 (hex): " + sha512Hex(s.getBytes("UTF-8")));
    }
}


------------------------------------
Hash + Salting 


import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;
import java.util.Arrays;

public final class PasswordManager {

    // Constants for PBKDF2
    private static final int ITERATIONS = 65536; // NIST recommends at least 10,000
    private static final int KEY_LENGTH = 256;   // Bits
    private static final int SALT_LENGTH = 16;   // Bytes

    private static final String ALGORITHM = "PBKDF2WithHmacSHA256";
    private static final SecureRandom RNG = new SecureRandom();

    /**
     * Generates a salted hash of the password.
     * Returns format: "salt:hash" (both Base64 encoded)
     */
    public static String hashPassword(String password) throws NoSuchAlgorithmException, InvalidKeySpecException {
        // 1. Generate a random salt
        byte[] salt = new byte[SALT_LENGTH];
        RNG.nextBytes(salt);

        // 2. Hash the password with the salt
        byte[] hash = pbkdf2(password.toCharArray(), salt);

        // 3. Encode both as Base64
        String saltB64 = Base64.getEncoder().encodeToString(salt);
        String hashB64 = Base64.getEncoder().encodeToString(hash);

        // 4. Return stored format
        return saltB64 + ":" + hashB64;
    }

    /**
     * Verifies a password against the stored "salt:hash" string.
     */
    public static boolean verifyPassword(String inputPassword, String storedPassword) 
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        
        // 1. Split the stored string into Salt and Hash
        String[] parts = storedPassword.split(":");
        if (parts.length != 2) return false;

        byte[] salt = Base64.getDecoder().decode(parts[0]);
        byte[] storedHash = Base64.getDecoder().decode(parts[1]);

        // 2. Hash the input password using the extracted salt
        byte[] inputHash = pbkdf2(inputPassword.toCharArray(), salt);

        // 3. Compare the hashes (using constant-time comparison for security)
        // standard Arrays.equals is vulnerable to timing attacks
        return slowEquals(storedHash, inputHash);
    }

    // Internal helper to perform the actual hashing
    private static byte[] pbkdf2(char[] password, byte[] salt) 
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        PBEKeySpec spec = new PBEKeySpec(password, salt, ITERATIONS, KEY_LENGTH);
        SecretKeyFactory skf = SecretKeyFactory.getInstance(ALGORITHM);
        return skf.generateSecret(spec).getEncoded();
    }

    // Constant-time comparison to prevent timing attacks
    private static boolean slowEquals(byte[] a, byte[] b) {
        int diff = a.length ^ b.length;
        for (int i = 0; i < a.length && i < b.length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    // Example Usage
    public static void main(String[] args) throws Exception {
        String rawPassword = "MySecurePassword123!";

        // 1. Registration: Hash the password
        String storedData = hashPassword(rawPassword);
        System.out.println("Stored in DB: " + storedData);

        // 2. Login: Verify correct password
        boolean isMatch = verifyPassword("MySecurePassword123!", storedData);
        System.out.println("Password Match? " + isMatch);

        // 3. Login: Verify wrong password
        boolean isWrong = verifyPassword("WrongPassword", storedData);
        System.out.println("Wrong Password Match? " + isWrong);
    }
}






